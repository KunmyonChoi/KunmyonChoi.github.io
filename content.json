{"meta":{"title":"Everyday Programmer","subtitle":"Javascript engineer blog","description":"Since 2006, as a software developer in LG Electronics, got various experiances on smart TV OS from Netcast to webOS. Member of EnyoJS open source project team. Swing dancer. Love dog, line dance and travel.","author":"Kunmyon Choi","url":"http://kunmyonchoi.github.io"},"pages":[{"title":"about","date":"2016-08-21T02:11:11.000Z","updated":"2016-10-22T11:32:36.000Z","comments":true,"path":"about/index.html","permalink":"http://kunmyonchoi.github.io/about/index.html","excerpt":"","text":"About DillyMember of EnyoJS javascript framework team. Writing Moonstone TV UI Library for webOS. Web front-end software engineer. Love HTML5, CSS3, ES6. About JaneShe is funny and lovely person. About my dogShe’s name is ‘Honey’. Love Jane and Dilly. Always jump when feels good. No barking. Sleep a lot."},{"title":"Categories","date":"2016-08-25T14:49:52.000Z","updated":"2016-08-25T14:49:52.000Z","comments":true,"path":"categories/index.html","permalink":"http://kunmyonchoi.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-25T14:49:52.000Z","updated":"2016-08-25T14:49:52.000Z","comments":true,"path":"tags/index.html","permalink":"http://kunmyonchoi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ES6 Object Literal Features","slug":"ES6-Object-Literal-Features","date":"2016-10-22T10:40:35.000Z","updated":"2016-10-22T11:28:12.000Z","comments":true,"path":"2016/10/22/ES6-Object-Literal-Features/","link":"","permalink":"http://kunmyonchoi.github.io/2016/10/22/ES6-Object-Literal-Features/","excerpt":"","text":"Property Value Shorthands먼저 아래 코드를 보면서 이야기를 시작해 보도록 하겠습니다. Example1234var foo = &apos;bar&apos;var baz = &#123; foo &#125;console.log(baz.foo)// &lt;- &apos;bar&apos; 위 코드에서 특이한 점이 보이시나요? 우선 foo가 { foo } 형태로 baz에 할당되는 것을 해석해 보면 { foo : foo }를 짧게 줄여서(shorthands) 쓴 것으로 이해할 수 있습니다. 다시 말해, var baz = { foo }는 아래와 같은 순서로 바꿔가며 해석될 수 있습니다. Equivalents123var baz = &#123; foo &#125;var baz = &#123; foo : foo &#125;var baz = &#123; foo : &apos;bar&apos; &#125; 결국 처음 코드는 아래와 동일한 코드로 볼 수 있습니다. Example123var baz = &#123; foo: &apos;bar&apos; &#125;console.log(baz.foo)// &lt;- &apos;bar&apos; Computed Property Names우선 아래 코드는 Hash 객체에 key를 변수 형태로 지정하기 위해 많이 사용되는 패턴 입니다. Use variable as a hash key12345var foo = &apos;bar&apos;var baz = &#123;&#125;baz[foo] = &apos;ponyfoo&apos;console.log(baz)// &lt;- &#123; bar: &apos;ponyfoo&apos; &#125; computed property name은 일반적인 property name 대신 대괄호 안에 쌓여진 표현식 사용할 수 있게 해줍니다. 대괄호 안의 표현식이 계산된 결과가 최종적인 property name으로 사용 됩니다. computed property name의 한가지 단점은 앞에서 설명한 shorthand 표현식을 사용할 수 없다는 점입니다. Syntax Error12345var foo = &apos;bar&apos;var bar = &apos;ponyfoo&apos;var baz = &#123; [foo] &#125;console.log(baz)// &lt;- SyntaxError 이 기능의 가장 빈번한 사용 예는 아래 케이스가 아닐까 싶습니다. 이 코드는 Computed Property Names를 사용하고 있으며 Computed Property Names를 사용하지 않았을 때와 비교해 3 스탭을 한 줄로 적을 수 있습니다. Common use case12345678function getModel (type) &#123; return &#123; [type]: &#123; message: &apos;hello, this is doge&apos;, date: new Date() &#125; &#125;&#125; 간략해 보이지 않나요? 참고) https://ponyfoo.com/articles/es6-object-literal-features-in-depth#computed-property-names 글을 번역한 내용에 기반 합니다.","categories":[],"tags":[{"name":"STANDARD","slug":"STANDARD","permalink":"http://kunmyonchoi.github.io/tags/STANDARD/"},{"name":"ES6","slug":"ES6","permalink":"http://kunmyonchoi.github.io/tags/ES6/"}]},{"title":"CSS3 Multiple Backgrounds","slug":"CSS-Multiple-Backgrounds","date":"2016-10-22T05:40:32.000Z","updated":"2016-10-22T10:51:12.000Z","comments":true,"path":"2016/10/22/CSS-Multiple-Backgrounds/","link":"","permalink":"http://kunmyonchoi.github.io/2016/10/22/CSS-Multiple-Backgrounds/","excerpt":"","text":"CSS Background 사용하기일반적으로 CSS background-image를 사용할 땐 하나의 div에 하나의 image 배경을 지정할 수 있는 것으로 알고 있고 그렇게 사용해 왔습니다. 일반적인 Background 지정 방법123.my-image &#123; background-image: url(my-image.png);&#125; 그러던 중 CodePen에 한 예제를 보고 나서 여러 image를 모아서 하나의 배경인 것 처럼 사용할 수 있는 방법이 있음알 알게 되었습니다. 참고) http://codepen.io/bali_balo/pen/amPkwQ?editors=0100 이는 여러 점들의 위치를 움직여 3차원 느낌이 나도록 해주는 재미있는 예제 입니다. 그런데 신기하게도 HTML 상에는 :before와 :after 밖에 보이지 않아 어떻게 된 영문인지 조금 더 들여다 보니 background를 이렇게 사용하고 있네요. 이런 문법이 있었던가? 싶은 마음에 CSS3 표준을 찾아 보았습니다. CSS3 Multiple Backgrounds 사용하기참고) http://www.w3schools.com/css/css3_backgrounds.asp CSS3는 하나의 element에 background-image 속성을 통해 하나 이상의 background image를 추가할 수 있게 허용합니다. CSS3의 다중 Background 지정 방법12345.my-image &#123; background-image: url(img_flwr.gif), url(paper.gif); background-position: right bottom, left top; background-repeat: no-repeat, repeat;&#125; 이는 여러 이미지를 콤마로 구분해 지정할 수 있게 해주는 방식인데, 이와 더불어 이미지의 위치나 크기 등도 마찬가지로 콤마로 구분해 여러 이미지에 대한 속성을 지정할 수 있습니다.","categories":[],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://kunmyonchoi.github.io/tags/CSS3/"},{"name":"STANDARD","slug":"STANDARD","permalink":"http://kunmyonchoi.github.io/tags/STANDARD/"}]},{"title":"npm global install troubleshooting","slug":"npm-global-install-troubleshooting","date":"2016-08-29T13:46:41.000Z","updated":"2016-08-29T13:50:51.000Z","comments":true,"path":"2016/08/29/npm-global-install-troubleshooting/","link":"","permalink":"http://kunmyonchoi.github.io/2016/08/29/npm-global-install-troubleshooting/","excerpt":"","text":"NPM permission 문제 해결하기개발 중 global 스콥으로 npm module을 설치하려고 하는 경우 access permission error를 접하게 되는 경우가 있다. 이런 경우 대부분은 공용 머신 이거나 mac과 같은 환경의 경우들이며, npm이 global 스콥으로 파일을 쓰려는 폴더에 접근 권한이 없는 것이 에러의 이유이다. 오늘은 이런 문제를 만날 경우 해결할 수 있는 방법을 알아 보도록 하겠다. EACCESS error는 다음과 같이 3가지 방법으로 해결이 가능하다. Option 1: npm의 기본 디렉터리 권한을 변경한다.1. npm의 디렉터리 상태를 확인한다.1npm config get prefix 많은 경우 /uer/local일 것이다. 만약 /usr로 되어 있다면 option 2로 해결해야 한다. 2. npm의 디렉터리에 owner를 현재 사용자로 설정한다.1sudo chown -R $(whoami) $(npm config get prefix)/&#123;lib/node_modules,bin,share&#125; 이 변경은 하위 폴더의 권한 까지 모두 변경한다. Option 2: npm의 기본 디렉터리를 다른 디렉터리로 변경한다./usr와 같이 공통 디렉터리의 owner를 변경하지 말아야 할 경우 이 방법을 사용한다. 1. hidden 디렉터리를 생성한다.1mkdir ~/.npm-global 2. npm의 기본 폴더를 변경한다.1npm config set prefix &apos;~/.npm-global&apos; 3. ~/.profile 파일을 생성하고 아래 내용을 추가한다.1export PATH=~/.npm-global/bin;$PATH 4. command line에서 아래를 수행한다.1source ~/.profile 이제 아래 명령으로 sudo 없이 global 설치가 되는지 확인한다. 1npm install -g jshint ~/.profile 파일 내용 변경을 원치 않는 경우 2~4 단계 대신 아래 명령으로 환경 변수를 바꾼다. 1NPM_CONFIG_PREFIX=~/.npm-global Option 3: 위 내용을 대신 해결해 주는 package manager를 사용한다.mac의 경우 Homebrew를 통해 fresh 설치하는 경우라면 위와 같은 작업이 필요하지 않다. 1brew install node 참고) 원문","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://kunmyonchoi.github.io/tags/npm/"}]},{"title":"Setup React with webpack and babel","slug":"Setup-React-with-webpack-and-babel","date":"2016-08-25T15:03:17.000Z","updated":"2016-08-29T13:47:23.000Z","comments":true,"path":"2016/08/26/Setup-React-with-webpack-and-babel/","link":"","permalink":"http://kunmyonchoi.github.io/2016/08/26/Setup-React-with-webpack-and-babel/","excerpt":"","text":"ES6 + Webpack + Babel React 개발 환경 꾸미기참고) Setting up React for ES6 with Webpack and Babel 본 글은 React 개발 환경을 처음부터 스스로 할 수 있도록 경험을 나누어 준 링크의 원문에 대한 번역을 기반으로 합니다. ReactJS가 유명세를 타면서 많은 사람들이 ReactJS 기반의 앱 개발을 배우기 위해 뛰어들고 있지만 ES6와 web pack 그리고 babel을 조합한 개발 환경에 필요한 많은 조합들은 여전히 먆은 개발자 들을 괘롭게 하고 있는 듯 합니다. 여기서 개발자 들이 혼란을 겪을 수 있는 부분이 있는데, ReactJS 개발을 위해 반드시 webpack이나 babel을 사용해야 하는 것은 아니라는 점입니다. 큰 SW를 모듈 기반으로 쪼개 개발하고 결과물로 만들어 내기 위해 모듈 간 의존성을 관리해 주는 webpack은 여러 모듈 시스템 중 하나일 뿐입니다. Babel은 아직 ES6 문법을 지원하지 않는 browser에서 ES6 문법을 기반으로 개발하기 위한 transpiler이며 ES6 문법을 사용하지 않을 경우, 즉 ES5를 사용하는 경우 궂이 Babel을 설정하지 않고도 ReactJS 개발이 가능합니다. 이 글에서는 ES6와 JSX 문법을 사용하고 webpack을 통해 모듈화 된 개발이 가능하게 하는 환경을 갖추는 것을 목표로 설명 합니다. Prerequisite설치를 시작하기 전 NodeJS와 npm이 설치되어 있는지 확인합니다. 이후 환경은 이들을 가지고 진행 됩니다. NodeJS와 npm이 설치된 상태에서 다음 명령을 터미널에 실행 합니다. 1npm init 이는 npm package manager를 통해 개발 환경을 만들기 위해 필요한 외부 패키지들의 목록과 이들의 버전을 트래킹 하기 위한 package.json 파일을 생성하는 명령이다. 추후 이 내용을 참조해 관련 패키지 들을 업데이트 받을 수 있다. 이제 다음 명령을 통해 react core와 react DOM을 설치하자. 12npm install --save react@0.14.7npm install --save react-dom@0.14.7 여기서 –save는 package.json에 dependencies 항목에 기록해 달라는 의미이며 @0.14.7은 react의 0.14.7 버전을 의미 한다. 이제 webpack과 webpack dev server를 설치할 차례다. 아마도 dev server를 global로 시스템 수준에 설치하려면 “sudo” 명령을 통해 관리 권한을 필요로 할지 모른다. 참고로 서버 관리 권한을 얻을 수 없는 경우라면 다음 링크를 통해 문제를 해결하자. sudo 없이 global로 nam 모듈을 설치하기 12npm install --save-dev webpack@1.12.12npm install webpack-dev-server@1.12.1 -g 여기서 –save-dev는 package.json의 devDependencies 항목에 추가해 달라는 의미이며 dependencies가 실행을 위해 필요한 의존성 이라면 devDependencies는 개발을 위해서만 필요한 의존성 패키지 들을 뜻한다. 예를 들어 unit tests, Coffeescript to Javascript transpilation, minification 등에 필요한 패키지는 devDependencies에 기술 되어야 한다. dependencies와 devDependencies의 차이 ‘-g’는 npm install을 실행한 폴더에 local로 설치하는 것이 아닌 시스템 수준의 패키지 설치를 의미하며, 따라서 한 시스템에서 여러번 실행할 필요는 없다. 이제 ES6 코드를 위해 transpiler를 설치할 차례이다. 그리고 이제 Babel이 등장할 차례 이기도 하다. Webpack과 함께 연동하기 위해 balel-loader와 babel-core를 설치하자. 또한 babel-loader를 통해 불러들일 ES2015와 React preset을 함께 설치하자. 1234npm install --save-dev babel-loader@6.2.1npm install --save-dev babel-core@6.4.5npm install --save-dev babel-preset-es2015@6.3.13npm install --save-dev babel-preset-react@6.3.13 이제 빌드에 필요한 모든 툴이 설치 되었다. 첫 React component 작성하기React에서 components는 어떻게 data가 보여져야 하는지를 기술하는 개별적인 빌딩 블록이다. ES6와 JSX 문법을 쓰지 않은 코드는 아래와 같이 작성할 수 있다. hello.js 파일을 생성하고 아래와 같이 첫번째 컴포넌트를 선언하자. 123456789var React = require(&apos;react&apos;); var Hello = React.createClass(&#123;displayName: &apos;Hello&apos;, render: function() &#123; return React.createElement(&quot;h1&quot;, null, &quot;Hello &quot;); &#125;&#125;);export default Hello; 이를 ES6 (import와 class 등을 눈여겨 보자)와 JSX 문법(HTML 문법을 사용하는 듯 한 착각을 불러 일으키게 한다. 이는 Facebook이 얼마나 PHP를 사랑하는지 알 수 있는 대목으로 이들은 일찍이 PHP 내에서 HTML 문법을 사용하기 위해 PHP 엔진을 뜯어 고쳤던 적이 있으며 이런 방식이 마음에 들었는지 이내 React에도 비슷한 방식을 적용해 JSX라고 이름 붙였다.)으로 작성하게 되면 아래와 같이 표현할 수 있다. 이로써 React.createClass를 사용하지 않고 코드를 좀 더 컴팩트 해 보이게 만들 수 있다. 123456789import React from &apos;react&apos;; class Hello extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello&lt;/h1&gt; &#125;&#125;export default Hello; JSX는 코드를 HTML과 유사한 느낌으로 작성할 수 있게 해준다는 장점 이외에도 React.createClass를 사용할 때 흔히 격는 nested block hell(조금만 구조가 복잡한 컴포넌트를 기술 하려 해도 코드를 해석하기 불가능할 정도로 block depth를 파악하기 어려워 지는 문제)에 빠지지 않게 도와준다. 123456789import React from &apos;react&apos;; class Hello extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello&lt;/h1&gt; &#125;&#125;export default Hello; 그리고 world.js 파일을 다음과 같이 준비한다. 123456789import React from &apos;react&apos;;class World extends React.Component &#123; render() &#123; return &lt;h1&gt;World&lt;/h1&gt; &#125;&#125;export default World; 이제 위에서 만들어진 두 모듈을 사용하는 ‘main.js’ 파일을 만들고 컴포넌트를 div 엘리먼트에 각각 mount 시켜 렌더링 해보자. 1234567891011121314import React from &apos;react&apos;;import ReactDom from &apos;react-dom&apos;import Hello from &quot;./hello.jsx&quot;;import World from &quot;./world.jsx&quot;;ReactDom.render( &lt;Hello/&gt;, document.getElementById(&apos;hello&apos;));ReactDom.render( React.createElement(World, null, null), document.getElementById(&apos;world&apos;)); 이제 webpack이 빌드하기 위한 옵션을 읽어올 webpack.config.js 파일에 필요한 정보를 기입하자. webpack은 ‘main.js’ 파일을 시작으로 import 관계에 따라 파일을 하나로 합쳐 app.js 파일을 생성해 낼 것이다. 이때 jsx로 끝나는 파일들의 경우 es2015와 react babel-loader preset을 통해 문법 변환을 먼저 수행한 뒤 파일을 합치도록 하자. 빌드에 필요한 npm 모듈들이 설치된 node_modules는 빌드 과정에서 합쳐지지 않도록 exclude 항목을 추가하는 것을 잊지 말자. 12345678910111213141516171819var path = require(&apos;path&apos;);var webpack = require(&apos;webpack&apos;); module.exports = &#123; entry: &apos;./main.js&apos;, output: &#123; path: __dirname, filename: &apos;app.js&apos; &#125;, module: &#123; loaders: [ &#123; test: /.jsx?$/, loader: &apos;babel-loader&apos;, exclude: /node_modules/, query: &#123; presets: [&apos;es2015&apos;, &apos;react&apos;] &#125; &#125; ] &#125;,&#125;; 다음으로 앱의 진입점이 될 ‘index.html’를 만들어 렌더링 될 타겟을 미리 생성해 두자. 마지막에 app.js 스크립트를 로딩하는 것으로 빌드와 실행을 위한 준비를 마친다. 123456789101112&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;hello&quot;&gt;&lt;/div&gt; &lt;div id=&quot;world&quot;&gt;&lt;/div&gt; &lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 자. 이제 web pack dev server를 실행해 우리가 작성한 컴포넌트가 웹 페이지 상에서 어떻게 보이는지 확인할 순서다. 1webpack-dev-server --progress --colors 이제 “http://localhost:8080/webpack-dev-server/” 주소에 접속해 브라우저에서 보면 첫 React 앱이 화면에 보여지고 있을 것이다.","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://kunmyonchoi.github.io/tags/ES6/"},{"name":"React","slug":"React","permalink":"http://kunmyonchoi.github.io/tags/React/"},{"name":"Babel","slug":"Babel","permalink":"http://kunmyonchoi.github.io/tags/Babel/"},{"name":"Build","slug":"Build","permalink":"http://kunmyonchoi.github.io/tags/Build/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-08-25T14:24:24.000Z","updated":"2016-08-25T14:49:52.000Z","comments":true,"path":"2016/08/25/hello-world/","link":"","permalink":"http://kunmyonchoi.github.io/2016/08/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"export default에 대해","slug":"about-export-default","date":"2016-08-17T15:50:33.000Z","updated":"2016-08-25T14:49:52.000Z","comments":true,"path":"2016/08/18/about-export-default/","link":"","permalink":"http://kunmyonchoi.github.io/2016/08/18/about-export-default/","excerpt":"","text":"http://www.2ality.com/2014/09/es6-modules-final.html 를 번역한 글입니다. ES6의 module 문법 표준에 따르면 export 는 2가지 종류가 있다. named exports (모듈 당 여러 개의 export)와 default exports (모듈 당 하나의 export)가 그것이다. named exports하나의 module 파일이라도 이 중 일부만 필요로 하는 경우가 있을 수 있다. 예를 들어 하나의 함수 혹은 하나의 클래스 만 사용하고 싶은 경우이다. 이런 때 es6 module 문법은 다음과 같은 형식으로 이를 가능하게 한다. 12345678910111213//------ lib.js ------export const sqrt = Math.sqrt;export function square(x) &#123; return x * x;&#125;export function diag(x, y) &#123; return sqrt(square(x) + square(y));&#125;//------ main.js ------import &#123; square, diag &#125; from &apos;lib&apos;;console.log(square(11)); // 121console.log(diag(4, 3)); // 5 또한 이런 형식도 가능하다. 1234//------ main.js ------import * as lib from &apos;lib&apos;;console.log(lib.square(11)); // 121console.log(lib.diag(4, 3)); // 5 default exportsnode 개발자는 변수 하나만 export 하는 등의 방식이 빈번히 사용되는데, front end 개발자의 경우는 constructor나 class를 export 하는 경우가 많다. 이런 경우 하나의 module이 하나의 export만 갖는 경우가 되는데 이런 때 사용할 수 있는 것이 default exports 이다. 123456789101112//------ myFunc.js ------export default function () &#123; ... &#125;;//------ main1.js ------import myFunc from &apos;myFunc&apos;;myFunc();//------ MyClass.js ------export default class &#123; ... &#125;;//------ main2.js ------import MyClass from &apos;MyClass&apos;;let inst = new MyClass(); es6에선 _가 default exports를 의미하며, each나 forEach는 named exports를 의미한다. 따라서 다음과 같이 default exports와 named exports를 동시에 얻는 방법도 가능하다. 123456789101112//------ underscore.js ------export default function (obj) &#123; ...&#125;;export function each(obj, iterator, context) &#123; ...&#125;export &#123; each as forEach &#125;;//------ main.js ------import _, &#123; each &#125; from &apos;underscore&apos;;...","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://kunmyonchoi.github.io/categories/Javascript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://kunmyonchoi.github.io/tags/ES6/"},{"name":"Standard","slug":"Standard","permalink":"http://kunmyonchoi.github.io/tags/Standard/"}]},{"title":"Easy Array Cloning","slug":"Easy-Array-Cloning","date":"2016-08-17T15:25:05.000Z","updated":"2016-08-25T14:49:52.000Z","comments":true,"path":"2016/08/18/Easy-Array-Cloning/","link":"","permalink":"http://kunmyonchoi.github.io/2016/08/18/Easy-Array-Cloning/","excerpt":"","text":"React를 사용하다 보면 immutable 이라는 단어를 많이 보게 됩니다. pure function으로 previous state와 action으로 next state를 생성하는 과정에서 이전 상태의 일부 값을 변경하는 것이 아니라 완전히 새로운 객체를 생성해 내게 됩니다. ReactElement 코드를 보면 다음과 같은 구문을 볼 수 있는데, 이는 Array를 복사한 새로운 Clone array를 만들어 내는 역할을 합니다. var shadowChildren = props.children.slice(0); 이렇게 복사된 객체가 이전과 동일한지 아래와 같이 확인해 볼 수 있다. See the Pen Array clone by Kunmyon Choi (@KunmyonChoi) on CodePen.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://kunmyonchoi.github.io/categories/Javascript/"}],"tags":[{"name":"Tip","slug":"Tip","permalink":"http://kunmyonchoi.github.io/tags/Tip/"}]},{"title":"ES6의 7번째 타입 Symbol","slug":"ES6-7th-type-Symbol","date":"2016-08-17T15:05:57.000Z","updated":"2016-08-25T14:49:52.000Z","comments":true,"path":"2016/08/18/ES6-7th-type-Symbol/","link":"","permalink":"http://kunmyonchoi.github.io/2016/08/18/ES6-7th-type-Symbol/","excerpt":"","text":"참고) http://hacks.mozilla.or.kr/2015/09/es6-in-depth-symbols/ 기존 JS는 다음과 같이 6가지 타입을 가지고 있었습니다. Undefined Null Boolean Number String Object Symbol은 7번째로 추가된 (문자열이나 객채가 아닌) 어떠한 값을 갖는 새로운 타입 입니다. 다음 코드는 Symbol이 활용될 수 있는 경우를 나타내는 예제 입니다. See the Pen dXAZqg by Kunmyon Choi (@KunmyonChoi) on CodePen. 예제 에서는 object 에 annotation 용도로 flag를 설정하고자 합니다. isMoving flag는 Symbol을 사용해 지정했고, isHaving flag는 일반적인 boolean property를 사용해 지정 했습니다. 결과를 비교해 보면 Object.keys() 에서 isMoving은 보이지 않지만 isHaving은 key로 나타납니다. 일반적으로 이렇게 property 삽입으로 변형된 array의 경우 Object.keys()나 for-in loop에 의도치 않게 key로 해석되어 나타나기 때문에 권장되는 방법이 아닙니다. Symbol은 이런 경우 key로 해석되지 않기 때문에 안전하게 사용이 가능합니다.","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://kunmyonchoi.github.io/categories/Javascript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://kunmyonchoi.github.io/tags/ES6/"},{"name":"Standard","slug":"Standard","permalink":"http://kunmyonchoi.github.io/tags/Standard/"}]}]}